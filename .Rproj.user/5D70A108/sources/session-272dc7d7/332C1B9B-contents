---
title: "Peaky Blinders Network Analysis"
author: "Matteo Larrode"
date: "2024-12-05"
output:
  pdf_document: default
  html_document: default
---

# Peaky Blinders Network Analysis (Part 2)

## Peaky Blinders Network

```{r message=FALSE, warning=FALSE}
library(igraph)
library(tidyverse)
library(gridExtra)
```

First, let's load the adjacency matrix of character interactions created previously. 
```{r}
peaky_df <- readRDS("data/cooccurrence_df.rds")

peaky_adj_mat <- as.matrix(peaky_df)
# no self-links
diag(peaky_adj_mat) <- 0
```

Now, we can create the network from the adjacency matrix:
```{r}
peaky_network <- graph_from_adjacency_matrix(peaky_adj_mat,
  mode = "undirected",
  weighted = TRUE
)
peaky_network <- set_vertex_attr(
  peaky_network,
  "name_edited",
  value = str_to_title(str_replace_all(V(peaky_network)$name, "_", " "))
)

peaky_network
```

And we can produce an initial plot!

```{r}
set.seed(10)
layout2 <- layout_with_kk(peaky_network)
layout4 <- layout_with_lgl(peaky_network)

plot.igraph(peaky_network,
  edge.color = "gray",
  edge.curved = .1,
  edge.width = 1 + E(peaky_network)$weight / 15,
  vertex.size = 3 + degree(peaky_network) / 3,
  vertex.frame.color = "#555555",
  vertex.label = V(peaky_network)$name_edited,
  vertex.color = "#FBD87F",
  vertex.label.color = "black",
  vertex.label.cex = 1 + betweenness(peaky_network, weights = NA) / 1000,
  margin = c(0, 0, 0, 0),
  asp = 0,
  layout = layout4,
  main = "Network of Peaky Blinders (Seasons 1-6)"
)
```

## Assortativity and communities

### Distinct subgroups, modularity and assortativity

Let's divide the network into three mutually exclusive subgroups depending of their city/country of origin, and their sex.

```{r}
# Orign
birmingham <- c(
  "Finn", "Arthur", "Thomas", "Freddie", "Danny", "Polly", "Ada",
  "Charlie", "John", "Curly", "Jeremiah", "Lizzie", "Michael", "Esme",
  "Karl", "Linda", "Aberama", "Bonnie", "Isiah", "Younger", "Erasmus",
  "Anna", "Moss", "Ruben", "Frances", "Barney", "Billy Kimber",
  "Johnny Dogs", "Jessie Eden", "Mrs Connors"
)

london <- c(
  "Churchill", "May", "Alfie", "Sabini", "Mitford", "Oswald Mosley", "Sabini",
  "Goliath", "Cyril", "Mr Levitt"
)

new_york <- c(
  "Luca Changretta", "Jack Nelson", "Vicente", "Gina", "Mrs Changretta"
)

ireland <- c(
  "Grace", "Campbell", "Hughes", "Laura Mckee", "Billy Grade", "Hayden Stagg"
)

russia <- c(
  "Tatiana", "Romanov", "Izabella"
)

# Gender
male <- c(
  "Finn", "Arthur", "Thomas", "Churchill", "Freddie", "Danny",
  "Charlie", "John", "Campbell", "Curly", "Younger", "Jeremiah",
  "Erasmus", "Michael", "Moss", "Karl", "Alfie", "Sabini",
  "Ruben", "Vicente", "Romanov", "Hughes", "Darby", "Aberama",
  "Bonnie", "Isiah", "Goliath", "Cyril", "Chang", "Barney",
  "Billy Kimber", "Johnny Dogs", "Luca Changretta", "Jimmy Mccavern",
  "Oswald Mosley", "Jack Nelson", "Mr Levitt", "Billy Grade",
  "Hayden Stagg"
)

female <- c(
  "Polly", "Ada", "Grace", "May", "Lizzie", "Esme", "Anna",
  "Izabella", "Frances", "Linda", "Tatiana", "Gina", "Mitford",
  "Mrs Connors", "Laura Mckee", "Evadne Barwell", "Mrs Changretta",
  "Jessie Eden"
)

# Create dataset
chr_variables <- data.frame(
  name_edited = V(peaky_network)$name_edited
) |>
  mutate(
    origin = as.factor(case_when(
      name_edited %in% birmingham ~ "Birmingham",
      name_edited %in% london ~ "London",
      name_edited %in% new_york ~ "New York",
      name_edited %in% ireland ~ "Ireland",
      name_edited %in% russia ~ "Russia",
      TRUE ~ "Other"
    )),
    origin_colour = case_when(
      origin == "Birmingham" ~ "#AAF7FF",
      origin == "London" ~ "#FFE099",
      origin == "New York" ~ "#CCBFFF",
      origin == "Ireland" ~ "#B2FF8C",
      origin == "Russia" ~ "#F76D5E",
      origin == "Other" ~ "#F2DACD"
    ),
    gender = as.factor(case_when(
      name_edited %in% male ~ "Male",
      name_edited %in% female ~ "Female",
      TRUE ~ "Unknown"
    )),
    gender_colour = case_when(
      gender == "Male" ~  "#FFFBA2", 
      gender == "Female" ~ "#40B0A6",
      TRUE ~ "grey")
  )
```

These character attributes are added to the network.

```{r}
peaky_network <- peaky_network |> 
  set_vertex_attr("origin", value = chr_variables$origin) |>
  set_vertex_attr("origin_colour", value = chr_variables$origin_colour) |> 
  set_vertex_attr("gender", value = chr_variables$gender) |> 
  set_vertex_attr("gender_colour", value = chr_variables$gender_colour)


gender_membership <- as.integer(V(peaky_network)$gender)
origin_membership <- as.integer(V(peaky_network)$origin)
```

We can now visualise the different subgroups in the network by colouring its vertices.

```{r}
plot.igraph(peaky_network,
  edge.color = "gray",
  edge.curved = .1,
  edge.width = 1 + E(peaky_network)$weight / 15,
  vertex.size = 3 + degree(peaky_network) / 3,
  vertex.frame.color = "#555555",
  vertex.label = V(peaky_network)$name_edited,
  vertex.color = V(peaky_network)$gender_colour,
  vertex.label.color = "black",
  vertex.label.cex = 1 + betweenness(peaky_network, weights = NA) / 1000,
  margin = c(0, 0, 0, 0),
  asp = 0,
  layout = layout4,
  main = "Network of Peaky Blinders (Seasons 1-6)"
)

legend(x = -1.15, y = 0.9,
       legend = c("Male", "Female"),
       col = c("black", "black"),
       pt.bg = c("#FFFBA2", "#40B0A6"),  # Background color of the points
       pch = 21,  # Type of points
       pt.cex = 3,  # Size of the points
       bty = "n",  # No box 
       text.col = "black")

text(0.7, -1, 
     paste0("Modularity: ", round(modularity(peaky_network,  membership = gender_membership), 3)), 
     cex = 1.2, 
     col = "black",
     font = 2)
```

```{r}
plot.igraph(peaky_network,
  edge.color = "gray",
  edge.curved = .1,
  edge.width = 1 + E(peaky_network)$weight / 15,
  vertex.size = 3 + degree(peaky_network) / 3,
  vertex.frame.color = "#555555",
  vertex.label = V(peaky_network)$name_edited,
  vertex.color = V(peaky_network)$origin_colour,
  vertex.label.color = "black",
  vertex.label.cex = 1 + betweenness(peaky_network, weights = NA) / 1000,
  margin = c(0, 0, 0, 0),
  asp = 0,
  layout = layout4,
  main = "Network of Peaky Blinders (Seasons 1-6)"
)

legend(x = -1.2, y = 1.3,
       legend = levels(V(peaky_network)$origin),
       col = c("black", "black"),
       pt.bg = levels(as.factor(V(peaky_network)$origin_colour)),  # Background color of the points
       pch = 21,  # Type of points
       pt.cex = 3,  # Size of the points
       bty = "n",  # No box 
       text.col = "black")

text(0.7, -1, 
     paste0("Modularity: ", round(modularity(peaky_network,  membership = origin_membership), 3)), 
     cex = 1.2, 
     col = "black",
     font = 2)
```

Now, we can calculate a modularity statistic using these subgroups, and interpret what the results imply for assortativity. 

```{r}
paste0("Modularity with respect to gender: ", modularity(peaky_network,  membership = gender_membership))
paste0("Modularity with respect to origin: ", modularity(peaky_network,  membership = origin_membership))

```

The modularity statistics for gender (0.0087) and origin (0.0139) are very close to zero. For instance, the proportion of character interactions within the same origin is a mere 0.0139 percentage points higher than what would be expected if all ties were formed at random.

In the context of Peaky Blinders, these modularity statistics indicate a very low level of assortativity based on gender and origin, i.e., interactions between characters are not markedly influenced by these attributes. Characters in the series therefore tend to interact across gender and origin lines, supporting a narrative where character interactions are primarily driven by plot needs and personal relationships rather than by their demographic backgrounds. 

### Continuous variable and assortativity 

Let's now calculate normalised closeness for all the nodes, and study assortativity with respect to this continuous variable. 

```{r}
paste0(assortativity(peaky_network, closeness(peaky_network, normalized = TRUE)))
```

There is a slight positive assortativity by closeness: the correlation between the closeness of linked vertices is 0.12 which is positive, albeit fairly weak. Characters which are closer on average to others in the network tend to interact more often amongst each other than with more peripheral characters, suggesting a subtle trend towards interaction among similarly influential characters within the narrative structure.

### Community detection algorithm

Having failed to detect a notable community, either by gender or origin earlier does not signify that there are no underlying subgroups influencing interactions between the characters of Peaky Blinders. Community detection algorithms can help detect these hidden communities.

To reduce subjectivity, multiple algorithms are compared: two node-moving algorithms based on modularity optimisation (Fast-greedy and Louvain) and one that minimises the expected description length of a random walker trajectory (InfoMAP).

#### Fast-greedy algorithm

```{r}
set.seed(123)

communities_fg <- cluster_fast_greedy(peaky_network)
table(membership(communities_fg))
```

The algorithm found four communities, let's visualise them.

```{r}
plot.igraph(peaky_network,
  edge.color = "gray",
  edge.curved = .1,
  edge.width = 1 + E(peaky_network)$weight / 15,
  vertex.size = 3 + degree(peaky_network) / 3,
  vertex.frame.color = "#555555",
  vertex.label = V(peaky_network)$name_edited,
  vertex.color = membership(communities_fg),
  vertex.label.color = "black",
  vertex.label.cex = 1 + betweenness(peaky_network, weights = NA) / 1000,
  margin = c(0, 0, 0, 0),
  asp = 0,
  layout = layout4,
)
```
#### Louvain algorithm

```{r}
set.seed(10)

communities_lou <- cluster_louvain(peaky_network)
table(membership(communities_lou))
```

The algorithm found agin four communities, but with different group sizes. Let's visualise these new groups.

```{r}
plot.igraph(peaky_network,
  edge.color = "gray",
  edge.curved = .1,
  edge.width = 1 + E(peaky_network)$weight / 15,
  vertex.size = 3 + degree(peaky_network) / 3,
  vertex.frame.color = "#555555",
  vertex.label = V(peaky_network)$name_edited,
  vertex.color = membership(communities_lou),
  vertex.label.color = "black",
  vertex.label.cex = 1 + betweenness(peaky_network, weights = NA) / 1000,
  margin = c(0, 0, 0, 0),
  asp = 0,
  layout = layout4,
)
```

A confusion matrix can help understand the differences between the two methods:

```{r}
table(membership(communities_fg), membership(communities_lou))
```
Both node moving algorithms (Fast-Greedy and Louvain) find 4 communities. 27 of the 28 members of Community 3 detected by the Fast Greedy method are consistently placed in the same community by the Louvain method, suggesting that these nodes likely form a tightly-knit or clearly defined cluster within the network, which both algorithms recognize and consistently categorize. Similarly, 10 nodes out of eleven from Fast Greedy's Community 2 were placed together by the Louvain algorithm. 

Nevertheless, the confusion matrix shows some differences between the two algorithms’ assignments. For instance, for Community 1 of Fast Greedy, the nodes are spread across four different communities in the Louvain method. This indicates that the cohesion within this group as perceived by the Fast Greedy method is not as strong under the criteria used by the Louvain algorithm. 

#### InfoMAP community detection algorithm

Rather than optimising modularity, InfoMAP minimises the expected description length of a random walker trajectory. In other words, the partition into communities is done so that walks should spend longer time within communities than between.

```{r}
communities_infomap_unweighted <- cluster_infomap(peaky_network, e.weights = NULL)
communities_infomap <- cluster_infomap(peaky_network)
table(membership(communities_infomap_unweighted))
table(membership(communities_infomap))
```

Interestingly, community detection with InfoMAP (weighted and unweighted) results in a single community. This is an indication that the flow of interactions between characters does not significantly bottleneck at any point that would otherwise suggest the presence of distinct groups.

When contrasted with the outputs from the previous algorithms, which identified multiple communities, the result from InfoMAP might indicate that the network is overall tightly-knit but contains subtler structures that are more sensitive to the parameters and methods of node-moving algorithms.

#### Compare Louvain algorithm and grouping by origin

```{r}
sort(membership(communities_lou))

table(V(peaky_network)$origin, membership(communities_lou))
```

Cross-tabulating the communities detected by the algorithm and character groupings by their city or country of origin yields interesting results. Although modularity alone had hinted that origin might not be a decisive factor for tie formation, there are some overlaps with the community attribution made by the Louvain algorithm. 

- Community 1 predominantly consists of characters from Birmingham (19 out of 31), suggesting that this community could represent the central group of characters based in Birmingham, likely reflecting the primary setting and central figures Peaky Blinders. Unsurprinsingly, all men of the Shelby family are in this community (Thomas, Arthur, Finn, John), as well as their trusted officers (Danny, Curly, Johnny Dogs)

- The other community mostly constituted of characters originating from Birmingham is Community 2 (9 out of 11). Interestingly, this second Birmingham-related community includes the most influential women in the Shelby family, such as Polly, the matriarch (along with her lover Aberama). In fact, from the Shelby siblings, all men are in Community 1, and the only woman, Ada, is isolated in Community 2 (along with her husband, Freddie, and son, Karl). These findings suggests that gender may indeed have a role in the creation of ties, along with family ties. 

- 93% of the characters from Birmingham are in either Community 1 or 2. Community 3 and Community 4 appear to be smaller and more diverse in terms of character origin. Community 4 has a slight concentration of characters from London (3 out of 6). However, this community seems to be constituted along narrative lines. Indeed, five of its members (Alfie and his dog Cyril, Sabini, Darby and Luca Changretta) are major antagonists of Peaky Blinders. 

- Finally, Community 3 is the most diverse, including characters from all origins, and possibly hinting at more internationally connected narratives or character interactions. For example, although Michael originates from Birmingham, he marries Gina and moves to New York, where she is from, to conducts business with her uncle Jack Nelson, therefore connecting two continents through his interactions. 

Overall, the Louvain community detection algorithm has uncovered communities in the narrative of Peaky Blinders, hidden when only considering single attributes at a time, but seemingly driven by interactions based on a set of factors including place of origin, gender, family or business. 

## Small-world and scale-free networks

- **Scale-free network**: In a scale-free network, most nodes have only a few connections, while a small number of nodes - often referred to as "hubs" - have a much large number of connections. A scale-free network is characterised by its highly uneven distribution of connections among the nodes. Specifically, this distribution follows a follows a power law, meaning that the probability of observing an node with 'x' connections decays as x increases: typically in the form P(x) = Cx^-α, with normalisation constant C and power law exponent α.

The power law is ubiquitous in nature and society, let's observe whether it characterises the interactions of Peaky Blinders characters.

First, degree distribution

```{r}
degree_data <- degree_distribution(peaky_network, cumulative = FALSE)
cumulative_degree_data <- degree_distribution(peaky_network, cumulative = TRUE)

degree_df <- data.frame(
  degree = seq_along(degree_data) - 1, 
  probability = degree_data)

cumulative_degree_df <- data.frame(
  degree = seq_along(cumulative_degree_data) - 1, 
  probability = cumulative_degree_data)

p1 <- ggplot(degree_df, aes(x = degree, y = probability)) +
  geom_line() +
  geom_point() +
  labs(title = "Degree Distribution", x = "Degree", y = "p(degree)") +
  theme_minimal()

p2 <- ggplot(cumulative_degree_df, aes(x = degree, y = probability)) +
  geom_line() +
  geom_point() +
  labs(title = "Cumulative Degree Distribution", x = "Degree", y = "p(degree)>x") +
  theme_minimal()

# Combining the plots side by side
grid.arrange(p1, p2, ncol = 2)

```

These plots hint at a potential power law distribution of degree. When picking a random node in the network, it has the highest probability of having a degree between 0 and 10, with a maximum at 3. Conversely, only a few nodes have especially high degrees (one at 54, and four others at 30 or above).

```{r}
# Remove zero probability & degree for log scale
degree_log_df <- degree_df[degree_df$probability > 0 & degree_df$degree > 0, ]

cumulative_degree_log_df <- cumulative_degree_df[cumulative_degree_df$probability > 0 & cumulative_degree_df$degree > 0, ]

log_log_degree_plot <- ggplot(degree_log_df, aes(x = degree, y = probability)) +
  geom_point() +
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Degree Distribution (Log-Log)", x = "Degree (log scale)", y = "p(degree) (log scale)") +
  theme_minimal()

log_log_cumulative_plot <- ggplot(cumulative_degree_log_df, aes(x = degree, y = probability)) +
  geom_point() +
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Cumulative Degree Distribution \n(Log-Log)", x = "Degree (log scale)", y = "p(degree)>x (log scale)") +
  theme_minimal()

log_log_cumulative_plot

```
The log-log plot of the cumulative degree distribution is a key visualization for analyzing the scale-free characteristics of a network. The beginning part of the cumulative degree distribution curve seems to follow a rough linear pattern in the log-log scale, suggesting a power-law regime typical for scale-free networks. Although towards the higher degrees, there appears to be more variation and a potential drop-off. This could indicate that while the network does exhibit scale-free characteristics for a range of degrees, it does not strictly follow a power-law distribution across all degrees, which could be due to the relatively small size of the network.

Several mechanisms can lead to the formation of scale-free networks, most of them are usually driven by some form of feedback loop. For example, preferential attachment - when new nodes prefer to attach to nodes that are already well-connected - and duplication are two of such mechanisms. A network of TV series character interactions is a special case because its interactions are solely driven by choices of the screenwriter to advance the plot, not by decisions made by the nodes themselves. 

The apparent scale-free characteristics observed in this network are therefore the manifestation of the structure of the series, centered around a few characters. The development of the power law distribution is caused by the need to advance the plot around the Shelby family, and side characters do not need to interact amongst each other. As the story advances and the network grows further, it could be expected that its scale-free proporty would be enhanced, as side or deceased characters, and antagonists from previous seasons stop appearing in the show and therefore cannot interact at all with new characters. 


- **Small-world phenomenon**: The small-world phenomenon refers to the property of a network wherein most nodes can be reached from every other node by a small number of steps, despite the network being very large. It is often quantified with a low average shortest path length, and is most likely to be exhibited by networks whose edges are mostly formed at random.

```{r}
# WITH THOMAS
# Calculate all shortest paths in the network
distances <- distances(peaky_network, weights = NA)
shortest_distances <- distances[upper.tri(distances)]

# Calculate the average shortest path length
average_path_length <- mean_distance(peaky_network, directed = FALSE, unconnected = FALSE, weights = NA)

# REMOVING THOMAS
peaky_network_modified <- delete_vertices(peaky_network, "thomas")
distances_modified <- distances(peaky_network_modified, weights = NA)
shortest_distances_modified <- distances_modified[upper.tri(distances_modified)]

# Recalculate the average shortest path length in the modified network
average_path_length_modified <- mean_distance(peaky_network_modified, directed = FALSE, unconnected = FALSE, weights = NA)

# Create a histogram of the shortest path distances
hist_data <- data.frame(
  PathLengths = shortest_distances,
  PathLengths_noThomas = shortest_distances_modified)

# Plotting
distances_hist <- ggplot(hist_data, aes(x = PathLengths)) +
  geom_bar(fill = "skyblue", color = "black") +
  scale_x_continuous(breaks = seq(min(hist_data$PathLengths, na.rm = TRUE), 
                                  max(hist_data$PathLengths, na.rm = TRUE), by = 1)) +
  labs(title = "Histogram of Shortest Path Lengths", x = "Shortest Path Length", y = "Frequency") +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())+
  annotate("text",
           x = 3, y = 620,
           label = paste0("Average Path Length: ", round(average_path_length, 2)),
           fontface = "bold")

distances_hist
```

The average path length of 3.25 and this histogram seem to suggest the network, which includes 57 nodes does exhibit small-world properties. 



## Exponential random graph modelling (ERGM)
